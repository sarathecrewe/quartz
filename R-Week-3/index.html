<!doctype html><html lang=en><head><meta charset=utf-8><meta name=description content="The pipe operator You will frequently need to perform a series of steps to answer a data related question.
Such a series of steps can often be represented as a nested function i."><meta property="og:title" content="R Week 3"><meta property="og:description" content="The pipe operator You will frequently need to perform a series of steps to answer a data related question.
Such a series of steps can often be represented as a nested function i."><meta property="og:type" content="website"><meta property="og:image" content="https://sarathecrewe.github.io/quartz/icon.png"><meta property="og:url" content="https://sarathecrewe.github.io/quartz/R-Week-3/"><meta property="og:width" content="200"><meta property="og:height" content="200"><meta name=twitter:card content="summary"><meta name=twitter:title content="R Week 3"><meta name=twitter:description content="The pipe operator You will frequently need to perform a series of steps to answer a data related question.
Such a series of steps can often be represented as a nested function i."><meta name=twitter:image content="https://sarathecrewe.github.io/quartz/icon.png"><title>R Week 3</title><meta name=viewport content="width=device-width,initial-scale=1"><link rel="shortcut icon" type=image/png href=https://sarathecrewe.github.io/quartz//icon.png><link href=https://sarathecrewe.github.io/quartz/styles.19109a40042e9f0e72e952fda4442a34.min.css rel=stylesheet><link href=https://sarathecrewe.github.io/quartz/styles/_light_syntax.86a48a52faebeaaf42158b72922b1c90.min.css rel=stylesheet id=theme-link><script src=https://sarathecrewe.github.io/quartz/js/darkmode.97a9259f642aeca7c654078a245d2f0c.min.js></script>
<script src=https://sarathecrewe.github.io/quartz/js/util.00639692264b21bc3ee219733d38a8be.min.js></script>
<link rel=preload href=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css as=style onload='this.onload=null,this.rel="stylesheet"' integrity=sha384-R4558gYOUz8mP9YWpZJjofhk+zx0AS11p36HnD2ZKj/6JR5z27gSSULCNHIRReVs crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js integrity=sha384-z1fJDqw8ZApjGO3/unPWUPsIymfsJmyrDVWC8Tv/a1HeOtGmkwNd/7xUS0Xcnvsx crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/contrib/copy-tex.min.js integrity=sha384-ww/583aHhxWkz5DEVn6OKtNiIaLi2iBRNZXfJRiY1Ai7tnJ9UXpEsyvOITVpTl4A crossorigin=anonymous></script>
<script src=https://cdn.jsdelivr.net/npm/@floating-ui/core@1.2.1></script>
<script src=https://cdn.jsdelivr.net/npm/@floating-ui/dom@1.2.1></script>
<script defer src=https://sarathecrewe.github.io/quartz/js/popover.aa9bc99c7c38d3ae9538f218f1416adb.min.js></script>
<script defer src=https://sarathecrewe.github.io/quartz/js/code-title.ce4a43f09239a9efb48fee342e8ef2df.min.js></script>
<script defer src=https://sarathecrewe.github.io/quartz/js/clipboard.2913da76d3cb21c5deaa4bae7da38c9f.min.js></script>
<script defer src=https://sarathecrewe.github.io/quartz/js/callouts.7723cac461d613d118ee8bb8216b9838.min.js></script>
<script>const SEARCH_ENABLED=!1,LATEX_ENABLED=!0,PRODUCTION=!0,BASE_URL="https://sarathecrewe.github.io/quartz/",fetchData=Promise.all([fetch("https://sarathecrewe.github.io/quartz/indices/linkIndex.62c7c913993ba624266631a5824c3355.min.json").then(e=>e.json()).then(e=>({index:e.index,links:e.links})),fetch("https://sarathecrewe.github.io/quartz/indices/contentIndex.7625e87d214cc0ebcf2d5dd5525eea7c.min.json").then(e=>e.json())]).then(([{index:e,links:t},n])=>({index:e,links:t,content:n})),render=()=>{const e=new URL(BASE_URL),t=e.pathname,n=window.location.pathname,s=t==n;addCopyButtons(),addTitleToCodeBlocks(),addCollapsibleCallouts(),initPopover("https://sarathecrewe.github.io/quartz",!0);const o=document.getElementById("footer");if(o){const e=document.getElementById("graph-container");if(!e)return requestAnimationFrame(render);e.textContent="";const t=s&&!1;drawGraph("https://sarathecrewe.github.io/quartz",t,[{"/moc":"#4388cc"}],t?{centerForce:1,depth:-1,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.5,linkDistance:1,opacityScale:3,repelForce:1,scale:1.4}:{centerForce:1,depth:1,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.6,linkDistance:1,opacityScale:3,repelForce:2,scale:1.2})}var i=document.getElementsByClassName("mermaid");i.length>0&&import("https://unpkg.com/mermaid@9/dist/mermaid.esm.min.mjs").then(e=>{e.default.init()});function a(n){const e=n.target,t=e.className.split(" "),s=t.includes("broken"),o=t.includes("internal-link");plausible("Link Click",{props:{href:e.href,broken:s,internal:o,graph:!1}})}const r=document.querySelectorAll("a");for(link of r)link.className.includes("root-title")&&link.addEventListener("click",a,{once:!0})},init=(e=document)=>{addCopyButtons(),addTitleToCodeBlocks(),renderMathInElement(e.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}],macros:{'â€™':"'"},throwOnError:!1})}</script><script type=module>
    import { attachSPARouting } from "https:\/\/sarathecrewe.github.io\/quartz\/js\/router.d6fe6bd821db9ea97f9aeefae814d8e7.min.js"
    attachSPARouting(init, render)
  </script><script defer data-domain=sarathecrewe.github.io/quartz src=https://plausible.io/js/script.js></script>
<script>window.plausible=window.plausible||function(){(window.plausible.q=window.plausible.q||[]).push(arguments)}</script></head><body><div id=search-container><div id=search-space><input autocomplete=off id=search-bar name=search type=text aria-label=Search placeholder="Search for something..."><div id=results-container></div></div></div><script src=https://cdn.jsdelivr.net/npm/flexsearch@0.7.21/dist/flexsearch.bundle.js integrity="sha256-i3A0NZGkhsKjVMzFxv3ksk0DZh3aXqu0l49Bbh0MdjE=" crossorigin=anonymous defer></script>
<script defer src=https://sarathecrewe.github.io/quartz/js/full-text-search.e6e2e0c213187ca0c703d6e2c7a77fcd.min.js></script><div class=singlePage><header><h1 id=page-title><a class=root-title href=https://sarathecrewe.github.io/quartz/>ðŸª´ Quartz 3.3</a></h1><div class=spacer></div><div id=search-icon><p>Search</p><svg tabindex="0" aria-labelledby="title desc" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 19.9 19.7"><title id="title">Search Icon</title><desc id="desc">Icon to open search</desc><g class="search-path" fill="none"><path stroke-linecap="square" d="M18.5 18.3l-5.4-5.4"/><circle cx="8" cy="8" r="7"/></g></svg></div><div class=darkmode><input class=toggle id=darkmode-toggle type=checkbox tabindex=-1>
<label id=toggle-label-light for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="dayIcon" viewBox="0 0 35 35" style="enable-background:new 0 0 35 35"><title>Light Mode</title><path d="M6 17.5C6 16.672 5.328 16 4.5 16h-3C.672 16 0 16.672.0 17.5S.672 19 1.5 19h3C5.328 19 6 18.328 6 17.5zM7.5 26c-.414.0-.789.168-1.061.439l-2 2C4.168 28.711 4 29.086 4 29.5 4 30.328 4.671 31 5.5 31c.414.0.789-.168 1.06-.44l2-2C8.832 28.289 9 27.914 9 27.5 9 26.672 8.329 26 7.5 26zm10-20C18.329 6 19 5.328 19 4.5v-3C19 .672 18.329.0 17.5.0S16 .672 16 1.5v3C16 5.328 16.671 6 17.5 6zm10 3c.414.0.789-.168 1.06-.439l2-2C30.832 6.289 31 5.914 31 5.5 31 4.672 30.329 4 29.5 4c-.414.0-.789.168-1.061.44l-2 2C26.168 6.711 26 7.086 26 7.5 26 8.328 26.671 9 27.5 9zM6.439 8.561C6.711 8.832 7.086 9 7.5 9 8.328 9 9 8.328 9 7.5c0-.414-.168-.789-.439-1.061l-2-2C6.289 4.168 5.914 4 5.5 4 4.672 4 4 4.672 4 5.5c0 .414.168.789.439 1.06l2 2.001zM33.5 16h-3c-.828.0-1.5.672-1.5 1.5s.672 1.5 1.5 1.5h3c.828.0 1.5-.672 1.5-1.5S34.328 16 33.5 16zM28.561 26.439C28.289 26.168 27.914 26 27.5 26c-.828.0-1.5.672-1.5 1.5.0.414.168.789.439 1.06l2 2C28.711 30.832 29.086 31 29.5 31c.828.0 1.5-.672 1.5-1.5.0-.414-.168-.789-.439-1.061l-2-2zM17.5 29c-.829.0-1.5.672-1.5 1.5v3c0 .828.671 1.5 1.5 1.5s1.5-.672 1.5-1.5v-3C19 29.672 18.329 29 17.5 29zm0-22C11.71 7 7 11.71 7 17.5S11.71 28 17.5 28 28 23.29 28 17.5 23.29 7 17.5 7zm0 18c-4.136.0-7.5-3.364-7.5-7.5s3.364-7.5 7.5-7.5 7.5 3.364 7.5 7.5S21.636 25 17.5 25z"/></svg></label><label id=toggle-label-dark for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="nightIcon" viewBox="0 0 100 100" style="enable-background='new 0 0 100 100'"><title>Dark Mode</title><path d="M96.76 66.458c-.853-.852-2.15-1.064-3.23-.534-6.063 2.991-12.858 4.571-19.655 4.571C62.022 70.495 50.88 65.88 42.5 57.5 29.043 44.043 25.658 23.536 34.076 6.47c.532-1.08.318-2.379-.534-3.23-.851-.852-2.15-1.064-3.23-.534-4.918 2.427-9.375 5.619-13.246 9.491-9.447 9.447-14.65 22.008-14.65 35.369.0 13.36 5.203 25.921 14.65 35.368s22.008 14.65 35.368 14.65c13.361.0 25.921-5.203 35.369-14.65 3.872-3.871 7.064-8.328 9.491-13.246C97.826 68.608 97.611 67.309 96.76 66.458z"/></svg></label></div></header><article><h1>R Week 3</h1><p class=meta>Last updated
Aug 16, 2023
<a href=https://github.com/jackyzha0/quartz/tree/hugo/content/R%20Week%203.md rel=noopener>Edit Source</a></p><ul class=tags></ul><aside class=mainTOC><details><summary>Table of Contents</summary><nav id=TableOfContents><ol><li><a href=#the-pipe-operator>The pipe operator</a></li><li><a href=#dplyr>dplyr</a></li><li><a href=#tibbles>Tibbles</a></li><li><a href=#row-operations>Row operations</a><ol><li><a href=#filter>Filter</a></li><li><a href=#distinct>Distinct</a></li><li><a href=#slice>Slice</a></li><li><a href=#arrange>Arrange</a></li></ol></li><li><a href=#column-operations>Column operations</a><ol><li><a href=#select>Select</a></li><li><a href=#pull>Pull</a></li><li><a href=#rename>Rename</a></li><li><a href=#relocate>Relocate</a></li><li><a href=#mutate>Mutate</a></li></ol></li><li><a href=#summarise-data>Summarise data</a><ol><li><a href=#summarise>Summarise</a></li><li><a href=#across>Across</a></li></ol></li><li><a href=#group-statistics>Group statistics</a><ol><li><a href=#group-by>Group by</a></li><li><a href=#window>Window</a></li><li><a href=#ranking>Ranking</a></li></ol></li></ol></nav></details></aside><a href=#the-pipe-operator><h2 id=the-pipe-operator><span class=hanchor arialabel=Anchor># </span>The pipe operator</h2></a><p>You will frequently need to perform a series of steps to answer a data related question.</p><p>Such a series of steps can often be represented as a <strong>nested function</strong> i.e.</p><p><a class="internal-link broken">300</a></p><ul><li>we start by first calculating <code>h(data)</code>,</li><li>then proceed to calculate <code>g(h(data)),</code></li><li>and finally calculate <code>f(g(h(data)))</code>.</li></ul><p>When a nested function consists of multiple functions and arguments it can become difficult to both write and read the function.</p><p>Alternatively, a series of steps can be viewed as a flow chart of <strong>functions</strong></p><p><a class="internal-link broken">470</a></p><ul><li>the <strong>function</strong> <code>f( )</code> process some data and sends the output to the <strong>function</strong> <code>g( )</code>,</li><li>the <strong>function</strong> <code>g( )</code> then process the output received from the <strong>function</strong> <code>f( )</code> and send the output to the function <code>h( )</code> and</li><li>the <strong>function</strong> <code>h( )</code> then process the output received from the <strong>function</strong> <code>g( )</code> and produce the final answer</li></ul><p>In this section we will discuss how we can write code in a flow chart style using the <strong>pipe operator</strong> <code>%>%</code>.</p><p>To illustrate how flow chart style code can be written, we will use the data set <code>mtcars</code>. To load the <code>mtcars</code> data set the <strong>function</strong> <code>data()</code> can be used</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>data(mtcars) # loads the data frame into the global environment
</span></span></code></pre></td></tr></table></div></div><p>The <code>mtcars</code> data set was extracted from the 1975 Motor Trend magazine, and comprises of the fuel consumption <code>mpg</code> and ten other accepts (features) of 32 automobiles (instances). We can view the first three <strong>rows</strong> of the data by using the <strong>function</strong> <code>head()</code></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>head(mtcars, n = 3) # displays the first three rows
</span></span></code></pre></td></tr></table></div></div><p>Using the data set <code>mtcars</code> we can calculate various statistics. For example, suppose that we want to determine the mean miles per gallon <code>mpg</code> of cars per their number of cylinders <code>cyl</code> for cars with more than one carburettors <code>carb</code>.</p><p><a class="internal-link broken">Example1.png</a></p><p>Our first option to calculate the statistic illustrated above is to break the calculation up into a series of steps, where we save the result of each step using an <strong>object</strong>.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl># 1. Remove cars with less than 2 carburettors 
</span></span><span class=line><span class=cl>a &lt;- filter(mtcars, carb &gt; 1) 
</span></span><span class=line><span class=cl># 2. Group data
</span></span><span class=line><span class=cl>b &lt;- group_by(a, cyl) 
</span></span><span class=line><span class=cl># 3. calculate the mpg mean per group 
</span></span><span class=line><span class=cl>c &lt;- summarise(b, mean(mpg)) 
</span></span><span class=line><span class=cl># 4. sort the results by cyl
</span></span><span class=line><span class=cl>arrange(c, cyl) 
</span></span></code></pre></td></tr></table></div></div><p>Breaking the calculation down into a series of steps makes it easy to read the code, however as a result unnecessary copies of the same <strong>object</strong> is created.</p><p>A second option to calculate the statistic of interest, is to use <strong>nested functions</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>arrange(summarise(group_by(filter(mtcars, carb &gt; 1), cyl), mean(mpg)), cyl)
</span></span></code></pre></td></tr></table></div></div><p>Using <strong>nested functions</strong> avoid the use of explicitly creating <strong>objects</strong>, but can the readability of the code be improved?</p><p>We can express the functions as a flow chart using the <strong>pipe operator</strong> <code>>%></code>.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>mtcars %&gt;% filter(carb &gt; 1) %&gt;% group_by(cyl) %&gt;% summarise(mean(mpg)) %&gt;% arrange(cyl)
</span></span></code></pre></td></tr></table></div></div><p>The <strong>pipe operator</strong> <code>>%></code> avoids creating unnecessary <strong>objects</strong> and makes it easier to read code. The <strong>pipe operator</strong> <code>>%></code> can be interpreted as a flow chart where we send <code>input</code> to a <strong>function</strong> that produces an <strong>output</strong>, the <strong>output</strong> is then be sent to the next <strong>function</strong></p><p><a class="internal-link broken">mtflow.png</a></p><p>To insert the <strong>pipe operator</strong> <code>>%></code> the shortcut <code>Ctrl + Shift + M</code> can be used. <strong>Pipes</strong> are clearer to read when each <strong>function</strong> is on a separate line</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>mtcars %&gt;% 
</span></span><span class=line><span class=cl>  filter(carb &gt; 1) %&gt;% 
</span></span><span class=line><span class=cl>  group_by(cyl) %&gt;% 
</span></span><span class=line><span class=cl>  summarise(mean(mpg)) %&gt;% 
</span></span><span class=line><span class=cl>  arrange(cyl)
</span></span></code></pre></td></tr></table></div></div><p>The thing to the left of a <strong>pipe operator</strong> <code>%>%</code> is <strong>passed</strong> to the <strong>first argument</strong> of the <strong>function</strong> on the __right __of the <strong>pipe operator</strong> <code>%>%</code>, while additional <strong>function arguments</strong> can be specified as usual</p><p>If you ever need to pass an <strong>object</strong> to an <strong>argument</strong> other then the <strong>first argument</strong>, set the <strong>argument</strong> equal to <code>.</code>. For example, <code>y %>% f(x,.)</code> is equivalent to <code>f(x,y)</code> and <code>z %>% g(x, y, arg = .)</code> is equivalent to <code>g(x,y,arg = z)</code></p><p>So far we have only illustrated how to print the results from <strong>pipe operations</strong>. We can also <strong>assign</strong> the <strong>output</strong> of a chain of <strong>pipe operations</strong> using the <strong>assignment operator</strong> <code>&lt;-</code></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>result &lt;- 
</span></span><span class=line><span class=cl>  mtcars %&gt;% 
</span></span><span class=line><span class=cl>  filter(carb &gt; 1) %&gt;% 
</span></span><span class=line><span class=cl>  group_by(cyl) %&gt;% 
</span></span><span class=line><span class=cl>  summarise(mean(mpg)) %&gt;% 
</span></span><span class=line><span class=cl>  arrange(cyl)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>result
</span></span></code></pre></td></tr></table></div></div><p><strong>Assignment</strong> can also be performed at the end of a chain using the <strong>assignment operator</strong> <code>-></code></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>mtcars %&gt;% 
</span></span><span class=line><span class=cl>  filter(carb &gt; 1) %&gt;% 
</span></span><span class=line><span class=cl>  group_by(cyl) %&gt;% 
</span></span><span class=line><span class=cl>  summarise(mean(mpg)) %&gt;% 
</span></span><span class=line><span class=cl>  arrange(cyl) -&gt; result
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>result
</span></span></code></pre></td></tr></table></div></div><p>Lastly, note that the the <strong>pipe operator</strong> can only be used if the <strong>package</strong> <code>tidyverse</code> is loaded.</p><a href=#dplyr><h2 id=dplyr><span class=hanchor arialabel=Anchor># </span>dplyr</h2></a><p>Given that our data is in a <strong>data frame</strong> we might want to <strong>manipulate</strong> the <strong>data frame</strong> in various ways, for example:</p><ul><li><strong>add</strong> or <strong>remove row(s)</strong> or <strong>column(s)</strong>,</li><li><strong>rearrange</strong> the <strong>row(s)</strong> or <strong>column(s)</strong> or</li><li><strong>change</strong> the <strong>names</strong> of <strong>column(s)</strong>.</li></ul><p>All the above examples can be implemented using base R, but the base <strong>functions</strong> is not self-describing. Using base R code to modify <strong>data frames</strong> often lead to <strong>nested functions</strong> that are difficult to read.</p><p>The <strong>package</strong> <code>dplyr</code> was created for the sole purpose of simplifying the process of <strong>manipulating</strong>, <strong>sorting</strong>, <strong>summarising</strong> and <strong>joining data frames</strong>. The <strong>functions</strong> included in the <code>dplyr</code> <strong>package</strong> often leads to (i) more efficient code, (ii) code that is easier to read and (iii) code that is easier to write</p><p>The <code>dplyr</code> <strong>package</strong> forms part of the <code>tidyverse</code> <strong>packages</strong>. This means that if you have <strong>installed</strong> the <code>tidyverse</code> <strong>package</strong> previously you do not have to reinstall the <code>dplyr</code> <strong>package</strong>. Once <strong>installed</strong> the <code>dplyr</code> package can be <strong>loaded</strong> using the <strong>function</strong> <code>library()</code></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>library(dplyr)
</span></span></code></pre></td></tr></table></div></div><p>The <code>dplyr</code> <strong>package</strong> includes various function to help you manipulate data frames. Some examples include:</p><table><thead><tr><th><strong>Function</strong></th><th><strong>Purpose</strong></th></tr></thead><tbody><tr><td><strong>filter()</strong></td><td>select <strong>row(s)</strong> to keep using conditions</td></tr><tr><td><strong>distinct()</strong></td><td>select unique <strong>rows(s)</strong></td></tr><tr><td><strong>slice</strong>_</td><td>select, remove or duplicate <strong>row(s)</strong></td></tr><tr><td><strong>arrange()</strong></td><td>order the <strong>rows</strong> of a data frame by the values of selected <strong>column(s)</strong></td></tr><tr><td><strong>select()</strong></td><td>select <strong>column(s)</strong> from a data frame to keep</td></tr><tr><td><strong>pull()</strong></td><td>select a single <strong>column</strong> of a data frame as a <strong>vector</strong></td></tr><tr><td><strong>rename()</strong></td><td>assign new names to one or more <strong>columns</strong></td></tr><tr><td><strong>relocate()</strong></td><td>change the order of <strong>columns</strong></td></tr><tr><td><strong>mutate()</strong></td><td>creates new <strong>columns(s)</strong></td></tr></tbody></table><a href=#tibbles><h2 id=tibbles><span class=hanchor arialabel=Anchor># </span>Tibbles</h2></a><p>In this lesson we will work with <strong>tibbles</strong> instead of traditional R <strong>data frames</strong>. <strong>Tibbles</strong> are <strong>data frames</strong>, but are tweaked to make our life a bit easier:</p><ul><li><strong>Tibbles</strong> are lazy i.e. the names and data types of columns are not automatically changed</li><li><strong>Tibbles</strong> are strict i.e. partial matching is not performed</li><li><strong>Tibbles</strong> are self-descriptive</li><li><strong>Tibbles</strong> print better than data frames</li><li><strong>Tibbles</strong> do not use row names</li><li>The <strong>column names</strong> of __tibbles __can be more descriptive e.g. white spaces can be used in <strong>column names</strong></li></ul><p>The <strong>function</strong> <code>class(</code>) can be used to verify that an <strong>object</strong> is a <strong>tibble</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>library(gapminder)
</span></span><span class=line><span class=cl>class(gapminder)
</span></span></code></pre></td></tr></table></div></div><p>When <strong>subsetting</strong> is performed on a <strong>data frame</strong> the <strong>result returned</strong> is not always a <strong>data frame</strong>. When we are unsure of the <strong>data type</strong> of an <strong>object</strong>, it becomes very difficult to write code in a flow chart style. How do we now that the next operation in our flow diagram will accept the <strong>data type</strong> pass to it?</p><ul><li>we will either have to keep track of the different <strong>data types</strong>,</li><li>write explicit <strong>tests</strong> or <strong>conversions</strong> to ensure the code execute without an error or</li><li>we can use <strong>tibbles</strong> .</li></ul><p>The main advantage of <strong>tibbles</strong>, in my opinion, is that when we apply a dplyr <strong>function</strong> to a <strong>tibble</strong> the results are always returned as a <strong>tibble</strong>:</p><p><a class="internal-link broken">470</a></p><a href=#row-operations><h2 id=row-operations><span class=hanchor arialabel=Anchor># </span>Row operations</h2></a><a href=#filter><h3 id=filter><span class=hanchor arialabel=Anchor># </span>Filter</h3></a><p><strong>Objective</strong>: Select rows to keep using <code>filter()</code></p><p><strong>Description</strong>: Filtering is a common task used to identify or select row(s) of a data set where a particular variable matches a specific value/condition</p><p><strong>Function</strong></p><p><code>filter(.data, ...)</code> or <code>data %>% filter(...)</code></p><table><thead><tr><th><strong>Argument</strong></th><th><strong>Description</strong></th></tr></thead><tbody><tr><td>.data</td><td>data frame or tibble</td></tr><tr><td>&mldr;</td><td>One or more expressions that returns logical vectors. When multiple expressions separated by commas are provided, the expressions are combined with the <strong>and</strong> <code>&</code> operator</td></tr></tbody></table><hr><p><em>Example 1</em></p><p>Select rows from the gapminder data set where the <code>country</code> is <strong>equal</strong> to <code>South Africa</code></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>gapminder %&gt;% filter(___)
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>gapminder %&gt;% filter(country == &#34;South Africa&#34;)
</span></span></code></pre></td></tr></table></div></div><p><em>Example 2</em></p><p>Select rows from the gapminder data set where the country is equal to South Africa or Lesotho</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>gapminder %&gt;% filter(country %in% ___)
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>gapminder %&gt;% filter(country %in% c(&#34;South Africa&#34;,&#34;Lesotho&#34;))
</span></span></code></pre></td></tr></table></div></div><p><em>Example 3</em></p><p>Select rows where the country is equal to South Africa and the year is greater than 2000</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>gapminder %&gt;% filter(country == &#34;South Africa&#34;, ___)
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>gapminder %&gt;% filter(country == &#34;South Africa&#34;, year &gt; 2000)
</span></span></code></pre></td></tr></table></div></div><p>or alternatively</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>gapminder %&gt;% filter(country == &#34;South Africa&#34; ___ year &gt; 2000)
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>gapminder %&gt;% filter(country == &#34;South Africa&#34; &amp; year &gt; 2000)
</span></span></code></pre></td></tr></table></div></div><p>Multiple logic rules can be applied in the <code>filter()</code> function</p><p>Rows can be filtered using the range of comparison operators, logical operators and functions to evaluate missing i.e. <code>NA</code> values</p><table><thead><tr><th>Operator</th><th>Description</th></tr></thead><tbody><tr><td>&lt;</td><td>Less than</td></tr><tr><td>></td><td>Greater than</td></tr><tr><td>==</td><td>Equal to</td></tr><tr><td>&lt;=</td><td>Less than or equal to</td></tr><tr><td>>=</td><td>Greater than or equal to</td></tr><tr><td>!=</td><td>Not equal to</td></tr><tr><td>%in%</td><td>Group membership</td></tr><tr><td>is.na</td><td>is NA</td></tr><tr><td>!is.na</td><td>is not NA</td></tr><tr><td>&</td><td>And</td></tr><tr><td>$</td><td>$</td></tr><tr><td>!</td><td>Not</td></tr></tbody></table><a href=#distinct><h3 id=distinct><span class=hanchor arialabel=Anchor># </span>Distinct</h3></a><p><strong>Objective</strong>: Select unique row(s)</p><p><strong>Description</strong>: Select unique row(s) based on a list of specified columns</p><p><strong>Function</strong></p><p><code>distinct(.data, ...)</code> or <code>data %>% distinct(...)</code></p><table><thead><tr><th><strong>Argument</strong></th><th><strong>Description</strong></th></tr></thead><tbody><tr><td>.data</td><td>data frame or tibble</td></tr><tr><td>&mldr;</td><td>Column names to use to determine uniqueness of a row. When multiple rows for a given combination of columns exists, only the first rows are preserved. When column names are not specified all columns are used to determine the uniqueness of a row</td></tr><tr><td>.keep_all</td><td>The default behaviour of the function is to drop all unspecified columns. If you want to get distinct rows by certain columns without dropping the other columns set the optional argument <code>.keep_all</code> to <code>TRUE</code></td></tr></tbody></table><hr><p><em>Example 1</em></p><p>Find all the unique years in the data set gapminder</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>gapminder %&gt;% distinct(___)
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>gapminder %&gt;% distinct(year)
</span></span></code></pre></td></tr></table></div></div><p>Note that a <strong>tibble</strong> is returned although the result can be easily represented by an <strong>atomic vector</strong></p><p><em>Example 2</em></p><p>Find all the unique years , but show all column</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>gapminder %&gt;% distinct(___)
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>gapminder %&gt;% distinct(year, .keep_all = TRUE)
</span></span></code></pre></td></tr></table></div></div><p>Only 12 rows are returned since the function <code>distinct()</code> only preserves the first distinct row.</p><a href=#slice><h3 id=slice><span class=hanchor arialabel=Anchor># </span>Slice</h3></a><p><strong>Objective</strong>: Select, remove or duplicate rows</p><p><strong>Description</strong>: The <code>slice_</code> <strong>functions</strong> include various functions to select, remove or duplicate rows. To illustrate how the <code>slice_</code> <strong>functions</strong> work we will look at the function <strong>slice_sample()</strong> which can be used to randomly select rows</p><p><strong>Function</strong></p><p><code>slice_sample(.data, ...)</code> or <code>data %>% slice_sample(...)</code></p><table><thead><tr><th><strong>Argument</strong></th><th><strong>Description</strong></th></tr></thead><tbody><tr><td>.data</td><td>data frame or tibble</td></tr><tr><td>n, prop</td><td>Provide either (i) <code>n</code> the number of rows to sample at random or (ii) <code>prop</code> to sample a proportion of rows from the data set</td></tr></tbody></table><hr><p><em>Example 1</em></p><p>Sample four random rows from the data set</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>set.seed(123) # makes random numbers repeatable 
</span></span><span class=line><span class=cl>gapminder %&gt;% ___ # select four random rows
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>set.seed(123) # makes random numbers repeatable 
</span></span><span class=line><span class=cl>gapminder %&gt;% slice_sample(n = 4) # selects four random rows
</span></span></code></pre></td></tr></table></div></div><a href=#arrange><h3 id=arrange><span class=hanchor arialabel=Anchor># </span>Arrange</h3></a><p><strong>Objective</strong>: Order the rows of a data frame by the values of selected column(s)</p><p><strong>Description</strong>: Often used to view the rows of an observation in a specific order based on a the values in a particular column</p><p><strong>Function</strong></p><p><code>arrange(.data, ...)</code> or <code>data %>% arrange(...)</code></p><table><thead><tr><th><strong>Argument</strong></th><th><strong>Description</strong></th></tr></thead><tbody><tr><td>.data</td><td>data frame or tibble</td></tr><tr><td>&mldr;</td><td>Names of columns to sort rows on separated by commas where the column names listed first takes precedence</td></tr></tbody></table><p>Values are sorted in ascending order by default. To sort in descending order using column <code>x</code> pass <code>desc(x)</code> to the <code>â€¦</code> argument of the <strong>function</strong> <code>arrange()</code></p><hr><p><em>Example 1</em></p><p>Sort the data frame gapminder by <code>continent</code> in <strong>ascending</strong> order and <code>country</code> in <strong>descending</strong> order</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>gapminder %&gt;% arrange(___)
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>gapminder %&gt;% arrange(continent, desc(country))
</span></span></code></pre></td></tr></table></div></div><a href=#column-operations><h2 id=column-operations><span class=hanchor arialabel=Anchor># </span>Column operations</h2></a><a href=#select><h3 id=select><span class=hanchor arialabel=Anchor># </span>Select</h3></a><p><strong>Objective</strong>: Select column(s) from a data frame to keep</p><p><strong>Description</strong>: Columns to keep can be selected based on the (i) column names, (ii) using a column range or (ii) by using helper functions</p><p><strong>Function</strong></p><p><code>select(.data, ...)</code> or <code>select %>% arrange(...)</code></p><table><thead><tr><th><strong>Argument</strong></th><th><strong>Description</strong></th></tr></thead><tbody><tr><td>.data</td><td>data frame or tibble</td></tr><tr><td>&mldr;</td><td>One or more unquoted column names, a range of column names to keep specified as x:y where x:y selects column x, column y and all the columns between the columns x and y, and/or using helper functions</td></tr></tbody></table><hr><p><em>Example 1</em></p><p>Select the columns country, year and population</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>gapminder %&gt;% 
</span></span><span class=line><span class=cl>  select(___)
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>gapminder %&gt;% 
</span></span><span class=line><span class=cl>  select(country, year, pop)
</span></span></code></pre></td></tr></table></div></div><p>alternatively we can specify the columns to remove using <code>-</code> signs</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>gapminder %&gt;% 
</span></span><span class=line><span class=cl>  select(___)
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>gapminder %&gt;% 
</span></span><span class=line><span class=cl>  select(-continent, -lifeExp, -gdpPercap)
</span></span></code></pre></td></tr></table></div></div><p><em>Example 2</em></p><p>We can also use the <code>:</code> symbol to select a range of columns</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>gapminder %&gt;% 
</span></span><span class=line><span class=cl>  select(country:year, pop)
</span></span></code></pre></td></tr></table></div></div><p>where the value <code>country:year</code> will select the <code>country</code> column, the <code>year</code> column and all columns between the <code>country</code> and <code>year</code> columns</p><p><em>Example 3</em></p><p>Various <strong>helper functions</strong> such as <code>starts_with()</code>, <code>ends_with()</code> and <code>contains()</code> can also be used to select columns based on conditions</p><p>Try selecting all columns that starts with the character <code>c</code> or contains the phrase <code>gdp</code></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>gapminder %&gt;% 
</span></span><span class=line><span class=cl>  select(___)
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>gapminder %&gt;% 
</span></span><span class=line><span class=cl>  select(starts_with(&#34;c&#34;), contains(&#34;gdp&#34;))
</span></span></code></pre></td></tr></table></div></div><p>The help file of the <strong>function</strong> <code>select()</code> can be viewed to see thevarious helper functions available i.e. <code>?select()</code></p><p><em>Example 4</em></p><p>To select <code>columns</code> based on column types, the helper function <code>where()</code> can be used. Try selecting all the numeric columns</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>gapminder %&gt;% 
</span></span><span class=line><span class=cl>  select(where(___))
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>gapminder %&gt;% 
</span></span><span class=line><span class=cl>  select(where(is.numeric))
</span></span></code></pre></td></tr></table></div></div><p>The <strong>function</strong> passed to the <code>argument</code> of <code>where()</code> should return a single <code>TRUE</code> or <code>FALSE</code>. If you are creative you can for instance remove all columns with more than 50% missing values</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>gapminder %&gt;% 
</span></span><span class=line><span class=cl>  select(where(function(x) sum(is.na(x)) / length(x) &lt; 0.5)) 
</span></span></code></pre></td></tr></table></div></div><a href=#pull><h3 id=pull><span class=hanchor arialabel=Anchor># </span>Pull</h3></a><p><strong>Objective</strong>: Select a single column of a data frame as a vector</p><p><strong>Description</strong>: Often in specific steps of an analysis a vector is required rather than a data frame. The <strong>function</strong> <code>pull(</code>) allows you to select a single column or value from a data frame as a vector</p><p><strong>Function</strong></p><p><code>pull(.data, ...)</code> or <code>select %>% pull(...)</code></p><table><thead><tr><th><strong>Argument</strong></th><th><strong>Description</strong></th></tr></thead><tbody><tr><td>.data</td><td>data frame or tibble</td></tr><tr><td>&mldr;</td><td>A column specified as (i) the column name or (ii) a positive integer, giving the position counting from left or (iii) a negative integer, giving the positing counting from right</td></tr></tbody></table><hr><p><em>Example 1</em></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>gapminder %&gt;% 
</span></span><span class=line><span class=cl>  pull(year)
</span></span></code></pre></td></tr></table></div></div><p>You can verify that the above returns a vector by running</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>gapminder %&gt;% 
</span></span><span class=line><span class=cl>  pull(year) %&gt;% 
</span></span><span class=line><span class=cl>  class()
</span></span></code></pre></td></tr></table></div></div><a href=#rename><h3 id=rename><span class=hanchor arialabel=Anchor># </span>Rename</h3></a><p><strong>Objective</strong>: Assign new names to one or more columns</p><p><strong>Description</strong>: Replace names of columns with descriptive names. Descriptive names improve readability and reduces the amount of formatting required e.g. when creating a plot</p><p><strong>Function</strong></p><p><code>rename(.data, ...)</code> or <code>rename</code> %>% pull(&mldr;)`</p><table><thead><tr><th><strong>Argument</strong></th><th><strong>Description</strong></th></tr></thead><tbody><tr><td>.data</td><td>data frame or tibble</td></tr><tr><td>&mldr;</td><td>Use <code>new_name = old_name</code> to rename a column. To rename multiple columns separate the assignments using commas i.e. <code>new_name_1 = old_name_1</code>, <code>new_name_2 = old_name_2</code></td></tr></tbody></table><hr><p><em>Example 1</em></p><p>Rename the columns <code>lifeExp</code> to <code>Life Expectancy</code> and <code>pop</code> to <code>Population</code></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>gapminder %&gt;% 
</span></span><span class=line><span class=cl>  rename(___ = ___, ___ = ___) 
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>gapminder %&gt;% 
</span></span><span class=line><span class=cl>  rename(&#34;Life Expectancy&#34; = lifeExp, 
</span></span><span class=line><span class=cl>         Population = pop) 
</span></span></code></pre></td></tr></table></div></div><p>In a <strong>tibble</strong>, unlike in a <strong>data frame</strong>, we can use spaces in column names given that the name is surrounded by double quotations <code>â€œ</code> or backticks `</p><a href=#relocate><h3 id=relocate><span class=hanchor arialabel=Anchor># </span>Relocate</h3></a><p><strong>Objective</strong>: Change the order of columns</p><p><strong>Description</strong>: Change the position of the columns of a data frame</p><p><strong>Function</strong></p><p><code>relocate(.data, ...)</code> or <code>relocate</code> %>% pull(&mldr;)`</p><table><thead><tr><th><strong>Argument</strong></th><th><strong>Description</strong></th></tr></thead><tbody><tr><td>.data</td><td>data frame or tibble</td></tr><tr><td>&mldr;</td><td>columns names separated by commas that will be moved to the front of the object passed to the <code>.data</code> argument</td></tr></tbody></table><p>The default arguments <code>.before</code> or <code>.after</code> of the <strong>function</strong> <code>relocate()</code> can be used to move a column(s) before or after a specific column. Only one of the default arguments can be used at a time</p><hr><p><em>Example 1</em></p><p>Move the column <code>pop</code> before the column <code>lifeExp</code></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>gapminder %&gt;% 
</span></span><span class=line><span class=cl>  relocate(___, ___) 
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>gapminder %&gt;% 
</span></span><span class=line><span class=cl>  relocate(pop, .before = lifeExp)
</span></span></code></pre></td></tr></table></div></div><a href=#mutate><h3 id=mutate><span class=hanchor arialabel=Anchor># </span>Mutate</h3></a><p><strong>Objective</strong>: Create new column(s)</p><p><strong>Description</strong>: Used to add new a column to a data set while preserving the old columns of the data set. The new variable can be derived from the values of another column(s) in the data set</p><p><strong>Function</strong></p><p><code>mutate(.data, ...)</code> or <code>mutate</code> %>% pull(&mldr;)`</p><table><thead><tr><th><strong>Argument</strong></th><th><strong>Description</strong></th></tr></thead><tbody><tr><td>.data</td><td>data frame or tibble</td></tr><tr><td>&mldr;</td><td>New column(s) specified as <code>name = value</code> and separated with a comma where the <code>value</code> can be: (i) a vector of length 1 which will be recycled, (ii) a vector of the same length as the number of rows, (iii) NULL to remove a column or (iv) a data frame or tibble to create multiple columns</td></tr></tbody></table><hr><p><em>Example 1</em></p><p>Create a new column <code>pop_in_million</code> which divided the values in the <code>pop</code> column by 1 000 000</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>gapminder %&gt;% 
</span></span><span class=line><span class=cl>  mutate(pop_in_million = ___)
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>gapminder %&gt;% 
</span></span><span class=line><span class=cl>  mutate(pop_in_million = pop/1000000)
</span></span></code></pre></td></tr></table></div></div><p>Additional <strong>columns</strong> can be added in a single <code>mutate()</code> call, by separating expressions with commas</p><p><em>Example 2</em></p><p>The <code>ifelse()</code> function can be used to assign values to a column based on a condition. Use the function <strong>mutate</strong> to change the country <code>Swaziland</code> to <code>Estwatini</code></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>gapminder %&gt;% 
</span></span><span class=line><span class=cl>  mutate(country == ifelse(___))
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>gapminder %&gt;% 
</span></span><span class=line><span class=cl>  mutate(country = ifelse(country == &#34;Swaziland&#34;,
</span></span><span class=line><span class=cl>                                      &#34;Eswatini&#34;,
</span></span><span class=line><span class=cl>                                      as.character(country))) 
</span></span></code></pre></td></tr></table></div></div><p>The <strong>function</strong> <code>mutate()</code> will replace the values in an existing column, when an existing column name is provided</p><p><em>Example 3</em></p><p>The <strong>function</strong> <code>case_when()</code> can be used to perform multiple <code>ifelse()</code> operations]</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>gapminder %&gt;% 
</span></span><span class=line><span class=cl>  mutate(gdp = case_when(gdpPercap &lt; 700 ~ &#34;Low&#34;, 
</span></span><span class=line><span class=cl>                         gdpPercap &lt; 800 ~ &#34;Moderate&#34;, 
</span></span><span class=line><span class=cl>                         TRUE ~ &#34;High&#34;))
</span></span></code></pre></td></tr></table></div></div><a href=#summarise-data><h2 id=summarise-data><span class=hanchor arialabel=Anchor># </span>Summarise data</h2></a><a href=#summarise><h3 id=summarise><span class=hanchor arialabel=Anchor># </span>Summarise</h3></a><p><strong>Objective</strong>: Calculate the summary statistic of specific columns</p><p><strong>Description</strong>: The <code>summarise()</code> <strong>function</strong> takes column(s) and computes something (any calculation that can aggregate multiple values into a single value) using the values of every row</p><p><strong>Function</strong></p><p><code>summarise(.data, ...)</code> or <code>summarise</code> %>% pull(&mldr;)`</p><table><thead><tr><th><strong>Argument</strong></th><th><strong>Description</strong></th></tr></thead><tbody><tr><td>.data</td><td>data frame or tibble</td></tr><tr><td>&mldr;</td><td>Summary statistic to calculate specified as <code>name = function()</code> where the <code>name</code> is optional and the <code>function()</code> can be any summary function like <code>min()</code>, <code>mean()</code> and <code>max()</code>. Multiple statistics can be calculated by separating summary statistics using commas or by using helper functions</td></tr></tbody></table><hr><p><em>Example 1</em></p><p>For South Africa, calculate the number of observations, max population, mean life expectancy and the range of life expectancy over the years</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>gapminder %&gt;% 
</span></span><span class=line><span class=cl>filter(country == &#34;South Africa&#34;) %&gt;% 
</span></span><span class=line><span class=cl>  summarise(count = n(),  # dplyr count function 
</span></span><span class=line><span class=cl>            max_pop = ___, 
</span></span><span class=line><span class=cl>            ___,
</span></span><span class=line><span class=cl>            range_life_exp = ___ - ___)
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>gapminder %&gt;% 
</span></span><span class=line><span class=cl>  filter(country == &#34;South Africa&#34;) %&gt;% 
</span></span><span class=line><span class=cl>  summarise(count = n(),  # dplyr count function 
</span></span><span class=line><span class=cl>            max_pop = max(pop), 
</span></span><span class=line><span class=cl>            mean(lifeExp),  # no name specified
</span></span><span class=line><span class=cl>            range_life_exp = max(lifeExp) - min(lifeExp))
</span></span></code></pre></td></tr></table></div></div><p>The new columns are calculated using all the rows of the gapminder data set filtered for the country South Africa</p><a href=#across><h3 id=across><span class=hanchor arialabel=Anchor># </span>Across</h3></a><p><strong>Objective</strong>: Avoid repetitive code due to applying the same function to multiple columns</p><p><strong>Description</strong>: The <code>across()</code> function is a <strong>helper function</strong> that can be used to apply one or more functions to one or more columns</p><p><strong>Function</strong></p><p><code>across(.cols, .fns)</code></p><table><thead><tr><th><strong>Argument</strong></th><th><strong>Description</strong></th></tr></thead><tbody><tr><td>.cols</td><td>A column name or a vector of column names e.g. c(col1, col2)</td></tr><tr><td>.fns</td><td>A <strong>reference</strong> to a function e.g. mean or a list of references to functions e.g. list(mean = mean, max = max, min = min)</td></tr></tbody></table><p>Note that a <strong>reference</strong> to a <strong>function</strong> must be provided i.e. a <strong>function</strong> without <strong>parenthesis</strong></p><hr><p><em>Example 1</em></p><p>Calculate the mean, maximum and minimum value of the column <code>lifeExp</code> and the column <code>pop</code></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>gapminder %&gt;% 
</span></span><span class=line><span class=cl>  filter(country == &#34;South Africa&#34;) %&gt;% 
</span></span><span class=line><span class=cl>  summarise(across(___, 
</span></span><span class=line><span class=cl>                   list(___)))
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>gapminder %&gt;% 
</span></span><span class=line><span class=cl>  filter(country == &#34;South Africa&#34;) %&gt;% 
</span></span><span class=line><span class=cl>  summarise(across(c(lifeExp, pop), 
</span></span><span class=line><span class=cl>                   list(mean = mean, 
</span></span><span class=line><span class=cl>                        max = max, 
</span></span><span class=line><span class=cl>                        min = min))) 
</span></span></code></pre></td></tr></table></div></div><p>Names are automatically created based on the column and list names</p><hr><p>The <strong>function</strong> <code>across(</code>)` can be used in additional ways to avoid repetition</p><ul><li><code>across(everything())</code> will summarise / mutate all columns. For example, to calculate the mean and standard deviation of all the columns for the data set data:</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>gapminder %&gt;% 
</span></span><span class=line><span class=cl>summarise(across(everything(), list(mean = mean, sd = sd)))
</span></span></code></pre></td></tr></table></div></div><ul><li><code>across(where())</code> will summarise / mutate all columns that satisfy some logical condition. For example, to calculate the mean and standard deviation for all numeric columns of the data set data</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>gapminder %&gt;% 
</span></span><span class=line><span class=cl>summarise(across(where(is.numeric), list(mean = mean, sd = sd))) 
</span></span></code></pre></td></tr></table></div></div><p>Other helper functions previously discussed can also be used inside the <strong>function</strong> across() e.g. <code>starts_with()</code>, <code>ends_with()</code> and <code>contains()</code></p><a href=#group-statistics><h2 id=group-statistics><span class=hanchor arialabel=Anchor># </span>Group statistics</h2></a><ul><li>To gain better insights, we can calculate statistics by a group</li><li>For example, suppose we have a data set composed of a key and data column. Then we can compute the mean of the values in the data column for each group or unique value present in the key column</li><li>The operations of calculating group statistics can be thought of as a split, apply and combine operation</li></ul><p><a class="internal-link broken">split.png</a></p><p>In the <code>dplyr</code> <strong>package</strong>, we will use the <code>group_by()</code> <strong>function</strong> to implement the split operation, while the <code>summarise()</code> <strong>function</strong> can be used to perform the apply and combine operations</p><a href=#group-by><h3 id=group-by><span class=hanchor arialabel=Anchor># </span>Group by</h3></a><p><strong>Objective</strong>: Group rows</p><p><strong>Description</strong>: Takes an existing data object and transform it into a grouped data object. Once a data set is grouped, operations can be performed &ldquo;by group&rdquo;</p><p><strong>Function</strong></p><p><code>group_by(.data, ...)</code> or <code>data %>% group_by(...)</code></p><table><thead><tr><th><strong>Argument</strong></th><th><strong>Description</strong></th></tr></thead><tbody><tr><td>.data</td><td>data frame or tibble</td></tr><tr><td>&mldr;</td><td>A column name to group the data frame by or multiple column names separated by commas</td></tr></tbody></table><ul><li>Also read up on the <code>ungroup()</code> <strong>function</strong></li></ul><hr><p><em>Example 1</em></p><p>Calculate the mean <code>lifeExp</code> per <code>country</code></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>gapminder %&gt;% 
</span></span><span class=line><span class=cl>  ___ %&gt;% 
</span></span><span class=line><span class=cl>  summarise(lifeExp_mean = mean(lifeExp)) 
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>gapminder %&gt;% 
</span></span><span class=line><span class=cl>group_by(country) %&gt;% 
</span></span><span class=line><span class=cl>summarise(lifeExp_mean = mean(lifeExp))  
</span></span></code></pre></td></tr></table></div></div><p>If we did not use the <code>group_by()</code> <strong>function</strong> in the example above, the operation would have computed the mean life expectancy using all the rows of the gapminder data set</p><a href=#window><h3 id=window><span class=hanchor arialabel=Anchor># </span>Window</h3></a><p>We have previously seen how we can compute some statistics of South Africa using the <code>summarise()</code> <strong>function</strong> i.e. calculating the minimum, mean and maximum life expectancy</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>gapminder %&gt;% 
</span></span><span class=line><span class=cl>  filter(country == &#34;South Africa&#34;) %&gt;% 
</span></span><span class=line><span class=cl>  select(lifeExp) %&gt;% 
</span></span><span class=line><span class=cl>  summarise(min_lifeExp = min(lifeExp), 
</span></span><span class=line><span class=cl>            mean_lifeExp = mean(lifeExp), 
</span></span><span class=line><span class=cl>            max_lifeExp = max(lifeExp))
</span></span></code></pre></td></tr></table></div></div><p>However, we do not have any way to directly calculate (i) how South Africa compares against other countries and (ii) whether the life expectancy of South Africa has improved or not</p><p><strong>Window functions</strong> allow us to compare rows to each other. We will start by looking at the two <strong>offset</strong> <strong>functions</strong> known as <code>lag()</code> and <code>lead()</code>. The <strong>function</strong> <code>lag()</code> retrieves the previous element of a <strong>vector</strong>, while the function <code>lead()</code> retrieves the next element of a <strong>vector</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>x &lt;- 1:5 
</span></span><span class=line><span class=cl>lag(x)
</span></span></code></pre></td></tr></table></div></div><p>In the example above, we use the <strong>function</strong> <code>lag()</code> to retrieve the previous element of the <strong>vector</strong> <code>x</code>. Since the first element of the <strong>vector</strong> <code>x</code> does not have a previous element the <strong>function</strong> <code>lag()</code> returns <code>NA</code></p><p>Accessing the previous and next __element __of a <strong>vector</strong> can help us to calculate <strong>trends</strong> or create new <strong>variables</strong></p><hr><p><em>Example 1</em></p><p>Calculate the change in life expectancy per <code>country</code> per year</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>gapminder %&gt;% 
</span></span><span class=line><span class=cl>  filter(year &gt; 2000) %&gt;% 
</span></span><span class=line><span class=cl>  arrange(country, year) %&gt;% 
</span></span><span class=line><span class=cl>  mutate(change_lifeExp = lifeExp - lag(lifeExp)) %&gt;%
</span></span><span class=line><span class=cl>  select(country, year, lifeExp, change_lifeExp)
</span></span></code></pre></td></tr></table></div></div><p>At first our code seems to work, but what happens when the <code>country</code> changes? To prevent the problem we can use <code>group_by()</code></p><p><em>Example 2</em></p><p>Calculate the change in life expectancy per <code>country</code></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>gapminder %&gt;% 
</span></span><span class=line><span class=cl>  filter(year &gt; 2000) %&gt;% 
</span></span><span class=line><span class=cl>  arrange(country, year) %&gt;% 
</span></span><span class=line><span class=cl>  group_by(country) %&gt;% 
</span></span><span class=line><span class=cl>  mutate(change_lifeExp = lifeExp - lag(lifeExp)) %&gt;% 
</span></span><span class=line><span class=cl>  select(country, year, lifeExp, change_lifeExp)
</span></span></code></pre></td></tr></table></div></div><a href=#ranking><h3 id=ranking><span class=hanchor arialabel=Anchor># </span>Ranking</h3></a><p><strong>Window functions</strong> allow us to compare <strong>rows</strong> to each other. <strong>Ranking functions</strong> takes a <strong>vector</strong> to order, and returns various types of <strong>ranks</strong>. The <strong>function</strong> <code>row_number()</code> assigns <strong>ranks</strong> to values in a <strong>vector</strong> based on the minimum value, where ties are resolved by <strong>assigning</strong> the lowest <strong>rank</strong> to the value that appears first</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>x &lt;- c(10, 2, 10, 6, 4) 
</span></span><span class=line><span class=cl>row_number(x)
</span></span></code></pre></td></tr></table></div></div><p>The <strong>function</strong> <code>min_rank()</code> works exactly the same as the <strong>function</strong> <code>row_number()</code> except that ties are resolved by assigning the same rank to equal values</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>x &lt;- c(10, 2, 10, 6, 4) 
</span></span><span class=line><span class=cl>min_rank(x)
</span></span></code></pre></td></tr></table></div></div><hr><p><em>Example 1</em></p><p>Rank the <code>countries</code> by <code>lifeExp</code> in the <code>year</code> 2007</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>gapminder %&gt;% 
</span></span><span class=line><span class=cl>  select(country, year, lifeExp) %&gt;% 
</span></span><span class=line><span class=cl>  filter(year == 2007) %&gt;% 
</span></span><span class=line><span class=cl>  mutate(rank = row_number(lifeExp)) %&gt;% 
</span></span><span class=line><span class=cl>  arrange(rank) 
</span></span></code></pre></td></tr></table></div></div></article><hr><div class=page-end id=footer><div class=backlinks-container><h3>Backlinks</h3><ul class=backlinks><li><a href=/quartz/Week-3/ data-ctx="R Week 3" data-src=/Week-3 class=internal-link>Week 3</a></li></ul></div><div><script src=https://cdn.jsdelivr.net/npm/d3@6.7.0/dist/d3.min.js integrity="sha256-+7jaYCp29O1JusNWHaYtgUn6EhuP0VaFuswhNV06MyI=" crossorigin=anonymous></script><h3>Interactive Graph</h3><div id=graph-container></div><style>:root{--g-node:var(--secondary);--g-node-active:var(--primary);--g-node-inactive:var(--visited);--g-link:var(--outlinegray);--g-link-active:#5a7282}</style><script src=https://sarathecrewe.github.io/quartz/js/graph.6579af7b10c818dbd2ca038702db0224.js></script></div></div><div id=contact_buttons><footer><p>Made by Nickipedia using <a href=https://github.com/jackyzha0/quartz>Quartz</a>, Â© 2023</p><ul><li><a href=https://sarathecrewe.github.io/quartz/>Home</a></li></ul></footer></div></div></body></html>